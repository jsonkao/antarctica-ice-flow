{"version":3,"sources":["shaders/image.frag","shaders/image.vert","image.js"],"names":["module","exports","imageTexture","regl","image","Image","main","drawImage","frag","vert","attributes","position","uniforms","texture","offset","prop","count","frame","tick","src","imageUrl","onload"],"mappings":";;;;;;;AAAAA,OAAOC,QAAQ;;ACAfD,OAAOC,QAAQ;;ACuCd,aAtCD,IAAA,EAAA,EAAA,QAAA,6BACA,EAAA,EAAA,QAAA,SAGA,EAAA,EAAA,QAAA,yBACA,EAAA,EAAA,QAAA,yBAiCC,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GApCD,IAKIC,EALEC,GAAO,EAAb,EAAA,WAOMC,EAAQ,IAAIC,MAOlB,SAASC,IACDC,IAAAA,EAAYJ,EAAK,CACrBK,KAAAA,EADqB,QAErBC,KAAAA,EAFqB,QAIrBC,WAAY,CACVC,SAAU,EAAE,EAAG,EAAG,GAAI,EAAG,EAAG,IAG9BC,SAAU,CACRC,QAASX,EACTY,OAAQX,EAAKY,KAAK,WAGpBC,MAAO,IAGTb,EAAKc,MAAM,SAAc,GAAXC,IAAAA,EAAAA,EAAAA,KACZX,EAAU,CACRO,OAAe,IAAPI,MAzBdd,EAAMe,IAAMC,EAAZ,QACAhB,EAAMiB,OAAS,WACbnB,EAAeC,EAAKU,QAAQT,GAC5BE","file":"image.a4a5d0a9.js","sourceRoot":"..","sourcesContent":["module.exports=\"precision mediump float;\\n#define GLSLIFY 1\\nuniform sampler2D texture;\\nuniform float offset;\\nvarying vec2 uv;\\n\\n// From Sam Hocevar and Emil Persson\\nvec3 rgb2hsv(vec3 c) {\\n  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\n  vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\\n  vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\\n\\n  float d = q.x - min(q.w, q.y);\\n  float e = 1.0e-10;\\n  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\\n}\\n\\n// From Iñigo Quiles via The Book of Shaders\\nvec3 hsv2rgb(vec3 c) {\\n  vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\\n                   0.0, 1.0);\\n  rgb = rgb * rgb * (3.0 - 2.0 * rgb);\\n  return c.z * mix(vec3(1.0), rgb, c.y);\\n}\\n\\nvoid main() {\\n  vec4 black = vec4(0, 0, 0, 1);\\n  vec4 textureColor = texture2D(texture, uv);\\n\\n  if (textureColor.a != 1.0) // Alpha is either 0 or 1\\n    discard;\\n\\n  // The input image is grayscale, which means R = G = B. To cycle each pixel\\n  // through the grayscale, we could equally offset each color component.\\n  // We could also use the HSV model to have more control over the hue of the\\n  // gradient. In the HSV model, gray colors lie on the central vertical axis\\n  // (H = *, S = 0, V ∈ [0, 1]). We can achieve the same color cycling effect\\n  // as before by offsetting V. But the ice looks prettier when cycling through\\n  // saturation (white ⟷ hue) rather than value (black ⟷ hue), so we offset\\n  // saturation using V as the initial value. We then set V to 1 for a light\\n  // color. Now we can also easily control the hue.\\n  vec3 hsv = rgb2hsv(textureColor.rgb);\\n\\n  // Helpful hues: darkblue (207), lightblue (183)\\n  vec3 color1 = vec3(207. / 360., mod(hsv[2] + offset, 1.0), 1.);\\n  vec3 color2 = vec3(183. / 360., mod(hsv[2] + offset, 1.0), 1.);\\n\\n  // Convert back to rgb and then multiply blend\\n  gl_FragColor = vec4(hsv2rgb(color1) * hsv2rgb(color2), 1);\\n}\\n\";","module.exports=\"precision mediump float;\\n#define GLSLIFY 1\\nattribute vec2 position;\\nvarying vec2 uv;\\n\\nvoid main() {\\n  uv = position;\\n  gl_Position = vec4(2.0 * position.x - 1.0, 1.0 - 2.0 * position.y, 0, 1);\\n}\\n\";","// import imageUrl from './images/ross-thin.png';\nimport imageUrl from './images/basic-paths.png';\nimport createREGL from 'regl';\nconst regl = createREGL();\n\nimport frag from './shaders/image.frag';\nimport vert from './shaders/image.vert';\n\nlet imageTexture;\n\nconst image = new Image();\nimage.src = imageUrl;\nimage.onload = function () {\n  imageTexture = regl.texture(image);\n  main();\n};\n\nfunction main() {\n  const drawImage = regl({\n    frag,\n    vert,\n\n    attributes: {\n      position: [-2, 0, 0, -2, 2, 2],\n    },\n\n    uniforms: {\n      texture: imageTexture,\n      offset: regl.prop('offset'),\n    },\n\n    count: 3,\n  });\n\n  regl.frame(({ tick }) => {\n    drawImage({\n      offset: tick * 0.01,\n    });\n  });\n}\n"]}